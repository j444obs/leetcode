## 一、前序遍历(非递归版)

## 思路：

>需要一个栈来辅助，把遍历结果push进数组中作为返回结果。
> 1. 将根节点放进栈中
> 2. 如果栈不为空，出栈一个节点push进数组中;如果该节点右子树不为空，把右子树放进栈中;
>    如果该节点左子树不为空，把左子树放进栈中
> 3. 重复步骤二，直到栈为空，返回数组

## 代码：

```
function preOrderTraversal(root){
	let res = [];
	let stack = [];
	if(root == null){
		return res
	}
	stack.push(root)
	while(stack.length){
		let node = stack.pop();
		res.push(node.val);
		if(node.right){
			stack.push(node.right);
		}
		if(node.left){
			stack.push(node.right);
		}
	}
	return res
}
```
## 二、中序遍历(非递归版)

## 代码：

```
function inOrderTraversal(root){
	let res = [];
	let stack = [];
	while(root != null || stack.length){
		if(root){
			stack.push(root);
			root = root.left;
		}else{
			let node = stack.pop();
			res.push(node.val);
			root = root.right;
		}
	}
	return res
}
```

## 三、后序遍历(非递归版)

## 代码：

```
function postOrderTraversal(root){
	let res = [];
	let stack = [];
	if(root == null){
		return res
	}
	stack.push(root);
	while(stack.length){
		let node = stack.pop();
		res.unshift(node.val);
		if(root.left){
			stack.push(node.left);
		}
		if(root.right){
			stack.push(node.right);
		}
	}
	return res
}
```

## 四、层次遍历

## 代码：

```

function printFromTopToBottom(root){
	let res = [];
	let queue = [];
	if(root == null){
		return res
	}
	queue.push(root)
	while(queue.length){
		let node = queue.shift();
		res.push(node.val);
		if(node.left != null){
			queue.push(node.left);
		}
		if(node.right != null){
			queue.push(node.right);
		}
	}
	return res;
} 

``` 

## 五、二叉树的深度 

## 思路：一旦没有找到节点就返回0，每弹出一次递归函数就会加一，树有三层就会得到3

## 代码：

```
function maxDepth(root){
	if(!root){
		return 0
	}
	return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
}
```

## 六、对称二叉树 

## 代码：

```
function isSymmetrical(pRoot){
    return pRoot == null || judge(pRoot.left, pRoot.right)
}
function judge(node1, node2){
    if(node1 == null && node2 == null){
        return true
    }else if(node1 == null || node2 == null){
        return false
    }
    if(node1.val !== node2.val){
        return false
    }else{
        return judge(node1.left, node2.right) && judge(node1.right, node2.left)
    }
}
```

## 七、平衡二叉树

## 代码：

```

function IsBalanced_Solution(pRoot){
    return depth(pRoot) !== -1
}
function depth(pRoot){
    if(pRoot == null){
        return 0
    }
    let left=depth(pRoot.left);
    if(left === -1){
        return -1
    }
    let right=depth(pRoot.right);
    if(right === -1){
        return -1
    }
    return Math.abs(left-right) > 1 ? -1 : Math.max(left, right) + 1
}
```

## 八、重建二叉树

## 九、按层打印二叉树

## 十、之字形打印二叉树

## 十一、二叉搜索树的后序遍历序列 

## 十二、二叉搜索树第K个节点

## 十三、二叉树的宽度 

## 十四、二叉树的镜像

## 十五、二叉树的下一个节点