## 一、封装bind

## 二、封装call

## 三、封装apply

## 四、手撕Map

## 代码：

```
const selfMap = function(fn, context) { // fn: 回调  context:回调作用域指定的this
        // 1. 获取调用者this,并转为数组
        var arr = [].slice.call(this);
        // 2. 遍历调用者
        var arrMap = [];
        for(var i = 0; i < arr.length; i++) {
            if(!arr.hasOwnProperty(i)) {
                continue;
            }
            arrMap.push(fn.call(context, arr[i], i, this));
        }
        return arrMap;
    }

```

## 五、深拷贝

## 第一种：递归

## 代码：

```
function deepClone(obj){
	let data;
	if(Object.prototype.toString.call(obj) === '[Object Array]'){
		data = [];
		for(let index=0; index<obj.length; index++){
			data.push(deepClone(obj[index]));
		}
	}else if(Object.prototype.toString.call(obj) === '[Object Object]'){
		data = {};
		for(let key in obj){
			data[key] = deepClone(obj[key]);
		}
	}else{
		return obj;
	}
	return data;
}
```

## 第二种：序列化与反序列化

## 代码：

```
function deepClone(obj){
	return JSON.parse(JSON.strigify(obj))
}
```


## 六、数组去重 

## 第一种：indxOf方法

> #### 时间复杂度：O(n^2)

## 代码：

```
function unique(arr){
	let temp = [];
	for(let i=0; i<arr.length; i++){
		if(temp.indexOf(arr[i]) === -1){
			temp.push(arr[i]);
		}
	}
	return temp;
}
```

## 第二种：排序后相邻去重法

> #### 时间复杂度：O(n log n)

## 代码：

```
function unique(arr){
 	arr.sort();
 	let temp = [arr[0]];
 	for(let i=1; i<arr.length; i++){
 		if(arr[i] !== temp[temp.length-1]){
 			temp.push(arr[i]);
 		}
 	}
 	return temp;
 }
```

## 第三种：ES6的Set方法

> #### 时间复杂度：O(n)

## 代码：

```
function unique(arr){
 	return [...new Set(arr)];
 }
```

## 七、数组扁平化

## 第一种：循环+递归

## 代码：
```
function flattenDeep(arr){
	let newArr=[];
	for(let i=0;i<arr.length;i++){
		if(Array.isArray(arr[i])){
			newArr.push.apply(newArr,flattenDeep(arr[i]));
		}else{
			newArr.push(arr[i]);
		}
	}
	return newArr;
}
```
## 第二种：apply()+some()

## 代码：
```
function flattenDeep(arr){
	while(arr.some(item=>Array.isArray(item))){
		arr=[].concat.apply([],arr);
	}
	return arr;
}
```
## 第三种：扩展运算符(...)

## 代码：
```
function flattenDeep(arr){
	while(arr.some(item=>Array.isArray(item))){
		arr=[].concat(...arr);
	}
	return arr;
}
```
## 第四种：reduce() 

## 代码：
```
function flattenDeep(arr){
	return arr.reduce((prev, next)=>{
		return prev.concat(Array.isArray(next) ? flattenDeep(next) : next);
	},[])
}
```
## 第五种：ES10 Api flat 

## 代码：
```
function flattenDeep(arr){
	return arr.flat(Infinity)
}
```
## 八、函数柯里化 

## 题目：
>实现add()方法，使计算结果能够满足如下预期:    
>   add(1)(2)(3) = 6;    
>   add(1, 2, 3)(4) = 10;    
>   add(1)(2)(3)(4)(5) = 15;    

## 代码：

```
function add() {
	// 第一次执行时，定义一个数组专门用来存储所有的参数
	var _args = Array.prototype.slice.call(arguments);

	// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
	var _adder = function() {
	    _args.push(...arguments);
	    return _adder;
	};

	// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
	_adder.toString = function () {
	    return _args.reduce(function (a, b) {
	        return a + b;
	    });
	}
	return _adder;
}
```

## 九、实现Instanceof

## 十、new的过程 

## 十一、手撕Promise

#### 简易版 

#### A+规范

## 十二、手撕Promise.all

## 十三、Promise封装异步上传图片

## 十四、红黄路灯(字节跳动经典面试题)

## 十五、spawn函数(Async函数实现原理)

## 十六、thunk函数(Generator函数实现自动流程管理原理)

